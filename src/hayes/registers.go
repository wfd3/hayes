package main

import (
	"fmt"
	"sort"
	"strconv"
	"sync"
)

type Registers struct {
	regs [__NUM_REGS]struct {
		val   byte
		valid bool
	}
	current int
	rlock   sync.RWMutex
}

// Register constants
// TODO: Fill this out as per the manual
const (
	// Do auto answer (0 == false, 1 == true) - default 0
	REG_AUTO_ANSWER = 0

	// AA Ring counter (read only)
	REG_RING_COUNT = 1

	// Escape sequence character ASCII code.  Default '+'
	REG_ESC_CH = 2

	// ASCII value of the line terminating character.  Defualt
	// ASCII 13 (<CR>)
	REG_CR_CH = 3

	// ASCII value of the line feed character.  Default ASCII 10 (<LF>)
	REG_LF_CH = 4

	// ASCII value of the backspace character.  Default is ASCII 8 (<BS>)
	REG_BS_CH = 5

	// determines how long the modem waits after going off-hook
	// before it dials.  Valid value is 4 - 7 seconds, factory
	// default is 4
	REG_BLIND_DIAL_WAIT = 6

	// time delay between dialing and responding to an incoming
	// carrier signal
	REG_WAIT_FOR_CARRIER_AFTER_DIAL = 7

	// duration of the delay generated by the comma (,) dial
	// modifier, in seconds
	REG_COMMA_DELAY = 8

	// carrier signal must be present for the modem to recognize
	// it and issue a carrier detect
	REG_CARRIER_DETECT_RESPONSE_TIME = 9

	// time between loss of remote carrier and local modem disconnect (0.1s)
	REG_DELAY_BETWEEN_LOST_CARRIER_AND_HANGUP = 10

	// duration and spacing of tones in multi-frequency tone dialing
	REG_MULTIFREQ_TONE_DURATION = 11

	// prior to and following the escape sequence.  In 1/50's of a
	// second, or in 20's of ms.  Factory default is 50 (1 second)
	REG_ESC_CODE_GUARD_TIME = 12

	// How long to wait to check DTR status (1/100ths of a second,
	// or in 10's ofms).  Factory default is 5 (50ms)
	REG_DTR_DETECTION_TIME= 25

	// If no data transfered in INACTIVITY_TIMER seconds, hangup
	// and return to command mode.  Default is 0, disabled.
	REG_INACTIVITY_TIMER = 30
)

const __NUM_REGS = 256

// Setup register defaults for the modem
func (r *Registers) Reset() {

	r.Write(REG_AUTO_ANSWER, 0)
	r.Write(REG_RING_COUNT, 0)
	r.Write(REG_ESC_CH, byte('+'))
	r.Write(REG_CR_CH, byte('\r'))
	r.Write(REG_LF_CH, byte('\n'))
	r.Write(REG_BS_CH, byte('\b'))
	r.Write(REG_BLIND_DIAL_WAIT, 2)
	r.Write(REG_WAIT_FOR_CARRIER_AFTER_DIAL, 50)
	r.Write(REG_COMMA_DELAY, 2)
	r.Write(REG_CARRIER_DETECT_RESPONSE_TIME, 6)
	r.Write(REG_DELAY_BETWEEN_LOST_CARRIER_AND_HANGUP, 14)
	r.Write(REG_MULTIFREQ_TONE_DURATION, 95)
	r.Write(REG_ESC_CODE_GUARD_TIME, 50)
	r.Write(REG_DTR_DETECTION_TIME, 5)
	r.Write(REG_INACTIVITY_TIMER, 0)

	// These are cosmetic, not functional.
	r.Write(18, 0)
	r.Write(26, 1)
	r.Write(36, 7)
	r.Write(37, 0)
	r.Write(38, 20)
	r.Write(44, 3)
	r.Write(46, 2)
	r.Write(48, 7)
	r.Write(49, 8)
	r.Write(50, 16)
	r.Write(97, 30)
	r.Write(108, 2)
	r.Write(109, 62)
	r.Write(110, 2)
}

var escSequence [3]byte = [3]byte{'+', '+', '+'}

func NewRegisters() *Registers {
	var r Registers

	r.current = 0

	// fill in the existing registers so valid() works
	for i := 0; i < __NUM_REGS; i++ {
		r.regs[i].val = 0
		r.regs[i].valid = false
	}

	return &r
}

func (r *Registers) valid(regnum uint) bool {
	r.rlock.Lock()
	defer r.rlock.Unlock()
	return r.regs[regnum].valid
}

func (r *Registers) ReadCurrent() byte {
	return r.Read(r.current)
}

// Note the locks here.
func (r *Registers) SetCurrent(regnum int) error {
	if regnum < 0 || regnum > __NUM_REGS {
		return fmt.Errorf("Invalid register numnber: %d", regnum)
	}
	r.rlock.Lock()
	defer r.rlock.Unlock()
	r.current = regnum
	return nil
}

func (r *Registers) ShowCurrent() int {
	r.rlock.RLock()
	defer r.rlock.RUnlock()
	return r.current
}

func (r *Registers) Write(regnum int, val byte) error {
	if regnum < 0 || regnum > __NUM_REGS {
		return fmt.Errorf("Invalid register numnber: %d", regnum)
	}
	r.rlock.Lock()
	defer r.rlock.Unlock()
	r.regs[regnum].val = val
	r.regs[regnum].valid = true
	return nil
}

func (r *Registers) Read(regnum int) byte {
	if regnum < 0 || regnum > __NUM_REGS {
		panic("invalid read register")
	}
	r.rlock.RLock()
	defer r.rlock.RUnlock()
	if r.regs[regnum].valid {
		return r.regs[regnum].val
	}
	return 0
}

func (r *Registers) Inc(regnum int) byte {
	r.rlock.Lock()
	defer r.rlock.Unlock()
	r.regs[regnum].val++
	r.regs[regnum].valid = true
	return r.regs[regnum].val
}

func (r *Registers) activeRegisters() (i []int) {
	r.rlock.RLock()
	defer r.rlock.RUnlock()
	for f := 0; f < __NUM_REGS; f++ {
		if r.regs[f].valid {
			i = append(i, f)
		}
	}
	sort.Ints(i)
	return i
}

func (r *Registers) String() string {
	var s string
	for _, f := range r.activeRegisters() {
		s += fmt.Sprintf("S%02d:%03d ", f, r.Read(f))
	}
	return lineWrap(s, 80)
}

func (r *Registers) JsonMap() map[string]byte {
	s := make(map[string]byte)
	for _, f := range r.activeRegisters() {
		k := strconv.Itoa(f)
		s[k] = r.Read(f)
	}
	return s
}

func registersJsonUnmap(m map[string]byte) *Registers {

	nr := NewRegisters()
	for key, val := range m {
		i, err := strconv.Atoi(key)
		if err != nil {
			logger.Printf("Atoi(): %s", err)
			continue
		}
		if i < 0 || i > 255 {
			logger.Printf("Bad register in config: regnum = %d", i)
		} else {
			nr.Write(i, val)
		}
	}
	return nr
}
